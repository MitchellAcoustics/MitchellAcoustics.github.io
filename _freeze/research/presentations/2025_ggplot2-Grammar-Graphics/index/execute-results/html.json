{
  "hash": "a284b57f19619cddf9a7060d88f19948",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data Visualization\"\nsubtitle: \"The Grammar of Graphics with `ggplot2`\"\ndate: \"2025-01-23\"\ndescription: Introductory lecture on the Grammar of Graphics and `ggplot2` for BSSC0021 - Business Statistics and Data Analytics.\nsidebar: false\ncategories: \n  - lecture\nimage: https://stat20.berkeley.edu/fall-2024/2-summarizing-data/03-a-grammar-of-graphics/images/plot-collage.png\n# bibliography: refs.bib\n\nformat:\n  live-revealjs: \n    theme: [default, clean.scss]\n    slide-number: true\n    show-slide-number: all\n    progress: true\n    transition: slide\n    background-transition: fade\n    preview-links: auto\n    width: 1247\n    height: 810\n    scrollable: true\n\ntitle-slide-attributes: \n  data-background-image: https://stat20.berkeley.edu/fall-2024/2-summarizing-data/03-a-grammar-of-graphics/images/plot-collage.png\n  data-background-position: right 0% bottom 50%\n  data-background-size: 50%\n  \nengine: knitr\n\nwebr:\n  cell-options:\n    autorun: false\n    fig-width: 7\n    fig-height: 3\n  # render-df: gt-interactive\n  packages:\n    - dplyr\n    - tidyr\n    - knitr\n    - ggplot2\n    - ggthemes\n    - palmerpenguins\n  \ncitation:\n  type: paper-conference\n  genre: Lecture\n  title: Data Visualization - The Grammar of Graphics with `ggplot2`\n  author:\n    - name: Andrew Mitchell\n  container-title: Lecture for BSSC0021 - Business Statistics and Data Analytics\n---\n\n\n\n\n## Introduction\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell autorun='true'}\n```{webr}\n#| include: false\n#| autorun: true\n\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(palmerpenguins)\nlibrary(ggthemes)\n```\n:::\n\n\n\n\n> \"The simple graph has brought more information to the data analyst's mind than any other device.\" — John Tukey\n\nR has several systems for making graphs, but `ggplot2` is one of the most elegant and most versatile. \n\n`ggplot2` implements the *grammar of graphics*, a coherent system for describing and building graphs. With `ggplot2`, you can do more and faster by learning one system and applying it in many places.\n\n::: aside\nThis presentation is based on the [Data Visualization](https://r4ds.had.co.nz/data-visualisation.html) chapter of the [R for Data Science](https://r4ds.had.co.nz/) book by Hadley Wickham and Garrett Grolemund.\n::::\n\n---\n\nIn this tutorial, we will create this plot:\n\n\n\n\n::: {.cell autorun='true'}\n```{webr}\n#| echo: false\n#| autorun: true\n#| fig-width: 10\n#| fig-height: 5\nintro_p <- penguins |>\n  drop_na() |> \n  ggplot(mapping = aes(x = flipper_length_mm, \n                       y = body_mass_g)) +\n    geom_point(mapping = aes(color = species, \n                             shape = species)) +\n    geom_smooth(method = \"lm\", formula = y ~ x) +\n    labs(title = \"Body Mass and Flipper Length\",\n         subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\",\n         x = \"Flipper Length (mm)\", \n         y = \"Body Mass (g)\",\n         color = \"Species\", \n         shape = \"Species\")\n\nintro_p\n```\n:::\n\n\n\n\n## The Grammar of Graphics\n\n::: {.columns}\n::: {.column width=\"50%\"}\nIn 1999, a statistician named Leland Wilkinson published the first edition of what has been the most influential work in data visualization, The Grammar of Graphics.\n\nThe most complete implementation of the grammar is found in an R package called `ggplot2` by Hadley Wickham.\n::::\n\n::: {.column width=\"50%\"}\n![The Grammar of Graphics, Wilkinson (1999)](img/grammar-graphics.png)\n::::\n::::\n\n## The Grammar of Graphics\n### A plot can be decomposed into three primary elements\n\n[1. the **data**]{.fragment .semi-fade-out fragment-index=1}\n\n[2. the **aesthetic mapping** of the variables in the data to visual cues]{.fragment .fade-in-then-semi-out fragment-index=1}\n\n[3. the **geometry** used to encode the observations on the plot.]{.fragment .fade-in-then-semi-out fragment-index=2}\n\n---\n\n![](img/graphics-layers.png)\n\n## Getting Started\n\nThroughout this lecture, we will be writing code together inside this webpage. \\\n\n\n\n\n::: {.cell exercise='getting-started' min-lines='5'}\n```{webr}\n#| exercise: getting-started\n#| min-lines: 5\n\n```\n:::\n\n\n\n\n::: {.hint exercise=\"getting-started\"}\n::: {.callout-tip collapse=\"false\"}\n## Hints:\n\nYou can type code into the cells and run them by clicking the \"Run\" button.\n\n\n\n\n::: {.cell}\n```{webr}\n\n2 + 3\n\n```\n:::\n\n\n\n\n::::\n::::\n\n\n## Getting Started\n### Packages\n\n::: {.colums}\n\n::: {.column width=\"50%\"}\nWe begin by loading the `tidyverse` and `ggplot2` packages. \\\n\nWe almost always begin our work by loading the tidyverse package. Note that the terms \"package\" and \"library\" are used interchangeably but that there is no package() function. To load a package, you need to use library().\n::::\n\n::: {.column .center width=\"50%\"}\n\n\n\n\n::: {.cell min-lines='3'}\n```{webr}\n#| label: getting-started\n#| min-lines: 3\n\n# Load the libraries\n\n```\n:::\n\n\n\n\n::::\n\n::::\n\n## Getting Started\n### Loading the Data\n\n::: {.columns}\n\n::: {.column width=\"50%\" .center}\n\nLoad the `palmerpenguins` package using library(). \n\nThis package contains the `penguins` dataset, which we will use for this tutorial.\n\n::::\n\n::: {.column width=\"50%\"}\n\n\n\n\n::: {.cell autorun='false' min-lines='2'}\n```{webr}\n#| autorun: false\n#| min-lines: 2\nlibrary(palmerpenguins)\n\n```\n:::\n\n\n\n\n::::\n\n::::\n\n## Getting Started\n### Getting help\n\n::: {.columns}\n\n:::: {.column width=\"40%\"}\n\nIf you are unsure about how to use a function, you can use the `?` operator to get help. \n\nFor a data package like `palmerpenguins`, you can use `?penguins` to get help on the dataset.\n\n::::\n\n:::: {.column width=\"60%\"}\n\n\n\n\n::: {.cell}\n```{webr}\n?penguins\n```\n:::\n\n\n\n\n::::\n:::\n\n## The Grammar of Graphics\n### The Data\n\n[ - A **variable** is a quantity, quality, or property that you can measure.]{.fragment .semi-fade-out fragment-index=1}\n\n[ - A **value** is the state of a variable when you measure it. The value of a variable may change from measurement to measurement.]{.fragment .fade-in-then-semi-out fragment-index=1}\n\n[ - An **observation** is a set of measurements made under similar conditions. An observation will contain several values, each associated with a different variable. We'll sometimes refer to an observation as a data point.]{.fragment .fade-in-then-semi-out fragment-index=2}\n\n[ - **Tabular data** is a set of values, each associated with a variable and an observation. Tabular data is *tidy* if each value is placed in its own \"cell\", each variable in its own column, and each observation in its own row.]{.fragment .fade-in-then-semi-out fragment-index=3}\n\n## The Grammar of Graphics\n### The Data\n\n::: {.columns}\n:::: {.column width=\"30%\"}\n- `species`: a penguin's species (Adelie, Chinstrap, or Gentoo).\n- `flipper_length_mm`: length of a penguin's flipper, in millimeters.\n- `body_mass_g`: body mass of a penguin, in grams.\n::::\n\n:::: {.column width=\"70%\"}\n::::: {.r-stack}\n\n::: {.fragment .fade-out fragment-index=1}\n\n\n\n::: {.cell}\n```{webr}\npenguins\n```\n:::\n\n\n\n\n:::\n\n::: {.fragment fragment-index=1}\n\n\n\n::: {.cell autorun='true'}\n```{webr}\n#| fig-width: 6.5\n#| fig-height: 4.8\n#| warning: false\n#| echo: false\n#| autorun: true\nggplot(data = penguins, \n       mapping = aes(x = bill_length_mm,\n                     y = bill_depth_mm,\n                     color = species)) +\n    geom_point()\n```\n:::\n\n\n\n:::\n\n:::::\n\n::::\n:::\n\n## Formulating our Research Question(s)\n\n::: {.incremental}\n- Do penguins with longer flippers weigh more or less than penguins with shorter flippers? You probably already have an answer, but try to make your answer precise. \n- What does the relationship between flipper length and body mass look like? Is it positive? Negative? Linear? Nonlinear? \n- Does the relationship vary by the species of the penguin? How about by the island where the penguin lives?\n:::\n\n## Building up a plot\n### Creating a ggplot \n\n::: {.columns}\n\n:::: {.column width=\"40%\"}\n\nWith **ggplot2**, you begin a plot with the function `ggplot()`, defining a plot object that you then add layers to. \\\n\nThe first argument of `ggplot()` is the dataset to use in the graph and so `ggplot(data = penguins)` creates an empty graph that is primed to display the penguins data, but since we haven't told it how to visualize it yet, for now it's empty. \\\n\n::::\n\n:::: {.column width=\"60%\"}\n\n\n\n\n::: {.cell exercise='empty-plot'}\n```{webr}\n#| exercise: empty-plot\n\n```\n:::\n\n\n\n\n::: {.hint exercise=\"empty-plot\"}\n::: {.callout-tip collapse=\"false\"}\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nggplot(data = penguins)\n```\n:::\n\n\n\n\n:::\n:::\n\n::::\n:::\n\n::: {.notes}\ninput `ggplot(data = penguins)`\n:::\n\n## Building up a plot\n\nThis is not a very exciting plot, but you can think of it like an empty canvas you'll paint the remaining layers of your plot onto. \\\n\nNext, we need to tell `ggplot()` how the information from our data will be visually represented. The mapping argument of the `ggplot()` function defines how variables in your dataset are mapped to visual properties (**aesthetics**) of your plot. \\\n\n. . .\n\nFor now, we will only map flipper length to the `x` aesthetic and body mass to the `y` aesthetic.\n\n## The Grammar of Graphics\n### Aesthetics\n\n![](img/aesthetics.png)\n\n## Building up a plot\n### Aesthetic mappings\n\n::: {.columns}\n\n:::: {.column width=\"40%\"}\n\nThe mapping argument is always defined in the `aes()` function, and the `x` and `y` arguments of `aes()` specify which variables to map to the `x` and `y` axes. \\\n\nFor now, we will only map flipper length to the `x` aesthetic and body mass to the `y` aesthetic. **ggplot2** looks for the mapped variables in the `data` argument, in this case, `penguins`.\n\n::::\n\n:::: {.column width=\"60%\"}\n\n\n\n\n::: {.cell exercise='aesthetic-mappings' autorun='false'}\n```{webr}\n#| exercise: aesthetic-mappings\n#| autorun: false\nggplot(\n  data = penguins,\n  mapping = ______________________\n)\n```\n:::\n\n\n\n\n::: {.hint exercise=\"aesthetic-mappings\"}\n::: {.callout-tip collapse=\"false\"}\n\n\n\n\n::: {.cell edit='false' autorun='false'}\n```{webr}\n#| edit: false\n#| autorun: false\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n)\n```\n:::\n\n\n\n\n:::\n:::\n\n::::\n:::\n\n::: {.notes}\nadd `mapping = aes(x = flipper_length_mm, y = body_mass_g)`\n\nOur empty canvas now has more structure -- it's clear where flipper lengths will be displayed (on the x-axis) and where body masses will be displayed (on the y-axis). But the penguins themselves are not yet on the plot. This is because we have not yet articulated, in our code, how to represent the observations from our data frame on our plot.\n:::\n\n## Building up a plot\n### Adding layers\n\nWe need to define a **geom**: the geometrical object that a plot uses to represent data. These geometric objects are made available in **ggplot2** with functions that start with `geom_`. \\\n\nPeople often describe plots by the type of geom that the plot uses:\n\n::: {.incremental}\n- bar charts use bar geoms (`geom_bar()`), \n- line charts use line geoms (`geom_line()`), \n- boxplots use boxplot geoms (`geom_boxplot()`), \n- scatterplots use point geoms (`geom_point()`), and so on.\n:::\n\nThe function `geom_point()` adds a **layer** of points to your plot, which creates a scatterplot. \n\n## Building up a plot\n### Add a scatter point layer to the plot:\n\n\n\n\n::: {.cell exercise='geom-point'}\n```{webr}\n#| exercise: geom-point\n#| fig-width: 9\n#| fig-height: 5\n#| fig-alt: |\n#|   A scatterplot of flipper length (x-axis) and body mass (y-axis) for penguins. The plot\n#|   displays a positive, linear, and relative strong relationship between these two variables.\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  __________________________\n\n```\n:::\n\n\n\n\n::: { .solution exercise=\"geom-point\" }\n::: { .callout-tip collapse=\"false\"}\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n```\n:::\n\n\n\n\n:::\n:::\n\n::: {.notes}\nadd `+ geom_point()`\n\nNow we have a scatterplot of flipper length (x-axis) and body mass (y-axis) for penguins. The plot displays a positive, linear, and relative strong relationship between these two variables.\n\nBefore we add more layers to this plot, let's pause for a moment and review the warning message we got:\n\nWe're seeing this message because there are two penguins in our dataset with missing body mass and/or flipper length values and ggplot2 has no way of representing them on the plot without both of these values. Like R, ggplot2 subscribes to the philosophy that missing values should never silently go missing. This type of warning is probably one of the most common types of warnings you will see when working with real data -- missing values are a very common issue and you'll learn more about them later. For the remaining plots we will suppress this warning so it's not printed alongside every single plot we make.\n:::\n\n## Building up a plot\n### Adding aesthetics\n\n::: {.columns}\n:::: {.column width=\"40%\"}\n::: {.r-stack}\n::: {.fragment .fade-out .smaller}\nIt's always a good idea to be skeptical of any apparent relationship between two variables and ask if there may be other variables that explain or change the nature of this apparent relationship. \n:::\n\n::: {.fragment .smaller}\nFor example, does the relationship between flipper length and body mass differ by species?\n\nWhen exploring relationships between variables, it's important to consider other variables that might affect the relationship. Let's incorporate `species` into our plot using color:\n:::\n:::\n::::\n\n:::: {.column width=\"60%\"}\n\n\n\n\n::: {.cell exercise='add-color'}\n```{webr}\n#| exercise: add-color\n#| warning: false\n#| fig-alt: |\n#|   A scatterplot of body mass vs. flipper length of penguins, with points \n#|   colored by species.\nggplot(\n  data = penguins,\n  mapping = aes(\n    x = flipper_length_mm, y = body_mass_g, \n    ______________________ )\n) +\n  geom_point()\n```\n:::\n\n\n\n\n::: {.hint exercise=\"add-color\"}\n::: {.callout-tip collapse=\"false\"}\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, \n  color = species)\n) +\n  geom_point()\n```\n:::\n\n\n\n\n:::\n:::\n\n::::\n:::\n\n::: {.notes}\nScatterplots are useful for displaying the relationship between two numerical variables, but it's always a good idea to be skeptical of any apparent relationship between two variables and ask if there may be other variables that explain or change the nature of this apparent relationship. \n\nFor example, does the relationship between flipper length and body mass differ by species? Let's incorporate species into our plot and see if this reveals any additional insights into the apparent relationship between these variables. We will do this by representing species with different colored points.\n\nTo achieve this, will we need to modify the aesthetic or the geom? If you guessed \"in the aesthetic mapping, inside of `aes()`\", you're already getting the hang of creating data visualizations with ggplot2! And if not, don't worry. \n\nAdd `color = species` to the aesthetic mapping. This tells ggplot2 to color the points by species.\n\nWhen we map a categorical variable to an aesthetic, ggplot2 automatically:\n- Assigns a unique value to each level (here, a unique color for each species)\n- Adds a legend explaining the mapping\n:::\n\n## Building up a plot\n### Add a trend line to see the relationship more clearly using `geom_smooth()`\n\n\n\n\n::: {.cell exercise='add-lm'}\n```{webr}\n#| exercise: add-lm\n#| warning: false\n#| fig-alt: |\n#|   A scatterplot of body mass vs. flipper length with trend lines by species.\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point() +\n  _______________\n```\n:::\n\n\n\n\n::: { .hint exercise=\"add-lm\" }\n::: { .callout-tip collapse=\"false\"}\nAdd a trendline (`geom_smooth(method = \"lm\")`) layer to the plot.\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\") \n```\n:::\n\n\n\n:::\n:::\n\n::: {.notes}\nNow let's add one more layer: a smooth curve displaying the relationship between body mass and flipper length. Before you proceed, refer back to the code above, and think about how we can add this to our existing plot.\n\nSince this is a new geometric object representing our data, we will add a new geom as a layer on top of our point geom: `geom_smooth()`. And we will specify that we want to draw the line of best fit based on a `l`inear `m`odel with `method = \"lm\"`.\n\nAdd `geom_smooth(method = \"lm\")` to the plot.\n\nThe method = \"lm\" argument tells geom_smooth() to use a linear model. Notice how the color aesthetic is inherited by both geoms, creating separate trend lines for each species.\n:::\n\n## Building up a plot {auto-animate=true}\n### Adding smooth curves\n\nIt's important to recognise how the **color aesthetic** is inherited by both **geoms**, creating separate trend lines for each species. \\\n\n```{.r code-line-numbers=\"|4\"}\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, \n  color = species)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n```\n\n::: {.notes}\nWe have successfully added lines, but this plot doesn't look like our ultimate goal plot, which only has one line for the entire dataset as opposed to separate lines for each of the penguin species.\n\nWhen aesthetic mappings are defined in `ggplot()`, at the *global* level, they're passed down to each of the subsequent geom layers of the plot. However, each geom function in ggplot2 can also take a `mapping` argument, which allows for aesthetic mappings at the *local* level that are added to those inherited from the global level. Since we want points to be colored based on species but don't want the lines to be separated out for them, we should specify `color = species` for `geom_point()` only.\n:::\n\n## Building up a plot {auto-animate=true}\n### Adding smooth curves\n\nIt's important to recognise how the **color aesthetic** is inherited by both **geoms**, creating separate trend lines for each species. \\\n\n```{.r code-line-numbers=\"6\"}\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, \n  color = species)\n) +\n  geom_point( <color = species> ) +\n  geom_smooth(method = \"lm\")\n\n```\n\n## Building up a plot {auto-animate=true}\n### Adding smooth curves\n\nIt's important to recognise how the **color aesthetic** is inherited by both **geoms**, creating separate trend lines for each species. \\\n\n```{.r code-line-numbers=\"7\"}\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, \n  color = species)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\", <color = species>)\n\n```\n\nPay attention to how the aesthetic mappings propagate through the layers of the plot. \n\nThis can be useful for creating complex plots with multiple layers, but it can also lead to unexpected results if you're not careful.\n\n## Building up a plot\n### Global vs Local aesthetics\n\n:::: {.columns}\n\n::: {.column width=\"40%\"}\nIn the previous plot, the color aesthetic was defined in the global mapping. This means that it applies to all geoms in the plot.\n\nTo get a single trend line while keeping colored points, we move the color aesthetic to `geom_point()`:\n:::\n\n::: {.column width=\"60%\"}\n\n\n\n\n::: {.cell exercise='local-aesthetics'}\n```{webr}\n#| exercise: local-aesthetics\n#| warning: false\n#| fig-alt: |\n#|   A scatterplot with colored points by species and a single trend line.\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(___________________________) +\n  geom_smooth(method = \"lm\")\n```\n:::\n\n\n\n\n::: {.hint exercise=\"local-aesthetics\"}\n::: {.callout-tip collapse=\"false\"}\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| warning: false\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species)) +\n  geom_smooth(method = \"lm\")\n```\n:::\n\n\n\n\n:::\n:::\n\n:::\n::::\n\n::: {.notes}\nAesthetic mappings can be defined at the global level (in ggplot()) or at the local level (in individual geoms). Local aesthetics override global ones.\n\nVoila! We have something that looks very much like our ultimate goal, though it's not yet perfect. We still need to use different shapes for each species of penguins and improve labels.\n\nIt's generally not a good idea to represent information using only colors on a plot, as people perceive colors differently due to color blindness or other color vision differences. Therefore, in addition to color, we can also map `species` to the `shape` aesthetic.\n:::\n\n## Building up a plot\n### Other aesthetics - shapes\n\n::: {.r-stack}\n:::: {.fragment .fade-out}\nIn addition to color, we can also map out variables to other aesthetic elements.\n\nHere, we map `species` to the `shape` aesthetic.\n::::\n\n:::: {.fragment .absolute top=100 width=95%}\n\n\n\n\n::: {.cell exercise='add-shape'}\n```{webr}\n#| exercise: add-shape\n#| warning: false\n#| fig-width: 10\n#| fig-height: 5\n#| fig-alt: |\n#|   A scatterplot of body mass vs. flipper length of penguins. Overlaid \n#|   on the scatterplot is a single line of best fit displaying the \n#|   relationship between these variables for each species (Adelie, \n#|   Chinstrap, and Gentoo). Different penguin species are plotted in \n#|   different colors and shapes for the points only.\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(\n    mapping = aes(color = species, ____________________)\n    ) +\n  geom_smooth(method = \"lm\")\n```\n:::\n\n\n\n\n::::: {.hint exercise=\"add-shape\"}\n:::::: {.callout-tip collapse=\"false\"}\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| warning: false\n#| fig-width: 10\n#| fig-height: 5\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species, shape = species)) +\n  geom_smooth(method = \"lm\")\n```\n:::\n\n\n\n\n::::::\n:::::\n::::\n:::\n\n::: {.notes}\nIt's generally not a good idea to represent information using only colors on a plot, as people perceive colors differently due to color blindness or other color vision differences. Therefore, in addition to color, we can also map `species` to the `shape` aesthetic.\n:::\n\n## Building up a plot {auto-animate=true}\n### Final touches\n\nThe **data portions** of our plot are now complete. But data visualization is not just about the data -- it's also about the **visual elements** that make the plot accessible and informative. \\\n\nWe also need the plot itself to communicate:\n\n::: {.incremental}\n\n- What the **plot is about** (title)\n- What the **axes represent**, including *units* (labels)\n- What the colors and shapes **represent** (legends)\n- Additional context such as the source of the data (subtitle or caption)\n:::\n\n## Building up a plot {auto-animate=true}\n### We can now add this information to our plot\n\n\n\n\n::: {.cell exercise='final-plot'}\n```{webr}\n#| warning: false\n#| exercise: final-plot\n#| fig-width: 12\n#| fig-height: 6\n#| fig-alt: |\n#|   The final version of our plot with proper labels and both color and shape aesthetics.\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(aes(color = species, shape = species)) +\n  geom_smooth(method = \"lm\") +\n  labs(\n    _____ = ________________, \n    color = \"Species\",\n    shape = \"Species\"\n  ) +\n  scale_color_colorblind()\n```\n:::\n\n\n\n\n::: {.hint exercise=\"final-plot\"}\n::: {.callout-tip collapse=\"false\"}\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| warning: false\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(aes(color = species, shape = species)) +\n  geom_smooth(method = \"lm\") +\n  labs(\n    title = \"Body Mass and Flipper Length\",\n    subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\",\n    x = \"Flipper Length (mm)\", \n    y = \"Body Mass (g)\",\n    color = \"Species\", \n    shape = \"Species\"\n  ) +\n  scale_color_colorblind()\n```\n:::\n\n\n\n\n:::\n:::\n\n::: {.notes}\nTo add:\n```r\ntitle = \"Body Mass and Flipper Length\",\nsubtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\",\nx = \"Flipper Length (mm)\", \ny = \"Body Mass (g)\",\ncolor = \"Species\", \nshape = \"Species\"\n```\n\nAnd finally, we can improve the labels of our plot using the `labs()` function in a new layer. \nSome of the arguments to `labs()` might be self explanatory: \n\n- `title` adds a title and `subtitle` adds a subtitle to the plot\n  \nOther arguments match the aesthetic mappings:\n\n- `x` is the x-axis label \n- `y` is the y-axis label \n- `color` and `shape` define the label for the legend. \n\nIn addition, we can improve the color palette to be colorblind safe with the `scale_color_colorblind()` function from the ggthemes package.\n:::\n\n## Some notes on `ggplot()` calls\n\n::: {.r-stack}\n::: {.fragment .fade-out fragment-index=\"1\" .center}\nSo far, we've written the code in a very explicit way, with each argument named. This is a good practice when you're learning, but it can be a bit verbose. \\\n::::\n\n::: {.fragment fragment-index=\"1\"}\nTypically, the first one or two arguments to a function are so important that you should know them by heart. The first two arguments to `ggplot()` are [**data**]{.fragment .highlight-blue fragment-index=\"2\"} and [**mapping**]{.fragment .highlight-blue fragment-index=\"2\"}. \n\n::: {.r-stack}\n[You'll often see them left out. This is true for other functions as well.]{.fragment .fade-out fragment-index=\"4\"}\n\n[When leaving the names out, the order of the arguments matters.]{.fragment fragment-index=\"4\"}\n:::\n\\\n\n::::\n:::\n\n::: {.r-stack}\n:::: {.fragment .fade-out fragment-index=\"2\" .absolute top=300 width=100%}\n```{.r}\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n```\n::::\n\n:::: {.fragment .fade-in-then-out fragment-index=\"2\" .absolute top=300 width=100%}\n```{.r code-line-numbers=\"2,3\"}\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n```\n::::\n\n:::: {.fragment .fade-in-then-semi-out fragment-index=\"3\" .absolute top=300 width=100%}\n```{.r code-line-numbers=\"1\"}\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) + \n  geom_point()\n```\n::::\n:::\n\n::: {.fragment fragment-index=\"4\" .absolute top=340 width=100%}\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n?ggplot\n```\n:::\n\n\n\n:::\n\n## Some notes on `ggplot()` calls {auto-animate=true}\n\nIn the future, you'll also learn about the pipe, `|>`, which operates similarly to the `+` operator in ggplot2.\n\nIt lets you chain together a series of operations, passing the output of one function to the input of the next. \\\n\n```{.r code-line-numbers=\"|1\"}\npenguins |> \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g)) + \n  geom_point()\n```\n\n## Some notes on `ggplot()` calls {auto-animate=true}\n\nIn the future, you'll also learn about the pipe, `|>`, which operates similarly to the `+` operator in ggplot2.\n\nIt lets you chain together a series of operations, passing the output of one function to the input of the next. \\\n\n```{.r code-line-numbers=\"2\"}\npenguins |> \n  ggplot(<penguins>, aes(x = flipper_length_mm, y = body_mass_g)) + \n  geom_point()\n```\n\n::: {.fragment}\nDon't worry if you don't understand this yet. It's just a sneak peek at what's to come.\n:::\n\n## Summary\n\nThe basic idea that underpins ggplot2: **a visualization is a mapping from variables in your data to aesthetic properties like position, color, size and shape.**\n\n- The grammar of graphics provides a systematic way to build visualizations\n- Start with data and aesthetic mappings\n- Add layers with geoms\n- Use different geoms for different types of variables\n- Enhance plots with labels, colors, and facets\n- Make sure your plots are clear and honest\n\n::: {.notes}\nKey takeaways:\n- Build plots layer by layer\n- Choose appropriate visualizations for your variable types\n- Consider your audience when making design choices\n- Use aesthetics and facets to show additional variables\n- Always aim for clear and accessible visualizations\n:::\n\n## That's it!\n\nWith our remaining time, I'd like you to practice with `ggplot2` using the DataAnalytics exercise. You should have already installed DataAnalytics with:\n\n```{.r}\ndevtools::install_github(\"antoinevernet/DataAnalytics\")\n```\n\nYou can then run the following code to get started:\n\n```{.r}\nlearnr::run_tutorial(\"02-Visualisation\", package = \"DataAnalytics\")\n```\n\n## Continuous Module Dialogue\n### Menti Survey\n\n![[https://www.menti.com/al7gkr8qhntz](https://www.menti.com/al7gkr8qhntz)](img/mentimeter_qr_code.png)\n\n## Visualizing distributions\n\nThe following are some additional slides on dealing with other data types and visualizing distributions in `ggplot2`. Explore them at your own pace.\n\n## Visualizing distributions\n### Categorical variables\n\nFor categorical variables like `species`, we use bar charts:\n\n\n\n\n::: {.cell}\n```{webr}\n#| fig-alt: |\n#|   A bar chart showing the frequency of each penguin species.\nggplot(penguins, aes(x = species)) +\n  geom_bar()\n```\n:::\n\n\n\n\n::: {.notes}\nA bar chart shows:\n- Categories on one axis\n- Counts (frequencies) on the other axis\n- Height of bars represents number of observations in each category\n:::\n\n## Visualizing distributions {visibility=\"hidden\"}\n### Improving categorical plots\n\nWe can reorder bars by frequency for better visualization:\n\n\n\n\n::: {.cell}\n```{webr}\n#| fig-alt: |\n#|   A bar chart with species ordered by frequency.\nggplot(penguins, aes(x = fct_infreq(species))) +\n  geom_bar()\n```\n:::\n\n\n\n\n::: {.notes}\nfct_infreq() is a function from forcats package that reorders factor levels by their frequencies. This makes the plot easier to read and interpret patterns.\n:::\n\n## Visualizing distributions\n### Numerical variables\n\nFor numerical variables like `body_mass_g`, we use histograms:\n\n\n\n\n::: {.cell}\n```{webr}\n#| warning: false\n#| fig-alt: |\n#|   A histogram showing the distribution of penguin body mass.\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 200)\n```\n:::\n\n\n\n\n::: {.notes}\nA histogram:\n- Divides the x-axis into bins\n- Height shows number of observations in each bin\n- binwidth controls the size of the bins\n- Different binwidths can reveal different patterns\n:::\n\n## Visualizing distributions\n### Exploring binwidth\n\nThe choice of binwidth affects what patterns we can see:\n\n\n\n\n::: {.cell layout-ncol=\"2\"}\n```{webr}\n#| warning: false\n#| layout-ncol: 2\n#| fig-width: 5\n#| fig-alt: |\n#|   Two histograms with different binwidths showing how binwidth affects visualization.\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 20)\n\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 2000)\n```\n:::\n\n\n\n\n::: {.notes}\n- Too small binwidth: too many bars, noisy pattern\n- Too large binwidth: too few bars, loses detail\n- Need to experiment to find the right balance\n:::\n\n## Visualizing distributions\n### Density plots\n\nAn alternative to histograms is the density plot:\n\n\n\n\n::: {.cell}\n```{webr}\n#| fig-alt: |\n#|   A density plot showing the distribution of penguin body mass.\n\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_density()\n```\n:::\n\n\n\n\n::: {.notes}\nDensity plots:\n- Show the shape of the distribution smoothly\n- Easier to compare multiple groups\n- Like a smoothed histogram\n- Think of it as draping a string over a histogram\n:::\n\n## Visualizing relationships\n### Numerical and categorical variables\n\nTo compare a numerical variable across categories, use boxplots:\n\n\n\n\n::: {.cell}\n```{webr}\n#| warning: false\n#| fig-alt: |\n#|   Box plots showing body mass distribution by species.\nggplot(penguins, aes(x = species, y = body_mass_g)) +\n  geom_boxplot()\n```\n:::\n\n\n\n\n::: {.notes}\nA boxplot shows:\n- Median (middle line)\n- IQR (box)\n- Whiskers (extend to most extreme non-outlier points)\n- Individual points for outliers\n:::\n\n## Visualizing relationships\n### Alternative views\n\nWe can also use density plots to compare distributions:\n\n\n\n\n::: {.cell}\n```{webr}\n#| warning: false\n#| fig-alt: |\n#|   Density plots of body mass by species.\nggplot(penguins, aes(x = body_mass_g, color = species, fill = species)) +\n  geom_density(alpha = 0.5)\n```\n:::\n\n\n\n\n::: {.notes}\n- color and fill aesthetics distinguish species\n- alpha controls transparency\n- Overlapping distributions show how groups compare\n:::\n\n## Visualizing relationships\n### Two categorical variables\n\nFor two categorical variables, use stacked bar plots:\n\n\n\n\n::: {.cell}\n```{webr}\n#| fig-alt: |\n#|   A stacked bar plot showing species distribution across islands.\nggplot(penguins, aes(x = island, fill = species)) +\n  geom_bar(position = \"fill\")\n```\n:::\n\n\n\n\n::: {.notes}\nposition = \"fill\":\n- Standardizes bars to same height\n- Shows proportions instead of counts\n- Better for comparing distributions across groups\n:::\n\n## Visualizing relationships\n### Three or more variables\n\nUse facets to split plots by a categorical variable:\n\n\n\n\n::: {.cell}\n```{webr}\n#| warning: false\n#| fig-width: 10\n#| fig-height: 3\n#| fig-alt: |\n#|   A faceted plot showing the relationship between body mass and flipper length for each island.\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species, shape = species)) +\n  facet_wrap(~island)\n```\n:::\n\n\n\n\n::: {.notes}\nfacet_wrap():\n- Creates separate plots for each category\n- Maintains same scales across plots\n- Useful for seeing patterns within groups\n- Alternative to mapping variables to aesthetics\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}