{
  "hash": "1345729722b9a968a729a7237b05e777",
  "result": {
    "markdown": "---\nlayout: post\ntitle: Clustering analysis in R, with `factoextra` and `NbClust`\ncategories: \n  - soundscape\n  - PhD\n  - machine learning\ndescription:  >\n  I recently gave a small talk on some packages I like using for doing clustering analysis in R. Here's a brief introduction to some features of factoextra and NbClust \nnoindex: true\ndate: \"2020-06-18\"\ncitation: true\nformat:\n  html:\n    code-fold: true\nexecute: \n  error: true\n---\n\n\n\n\n## Clustering Analysis Libraries\n\n`factoextra`: \n\n * [https://www.rdocumentation.org/packages/factoextra/versions/1.0.3](https://www.rdocumentation.org/packages/factoextra/versions/1.0.3)\n\n`NbClust`: \n\n * [https://www.rdocumentation.org/packages/NbClust/versions/3.0](https://www.rdocumentation.org/packages/NbClust/versions/3.0)\n * [https://www.jstatsoft.org/article/view/v061i06/v61i06.pdf](https://www.jstatsoft.org/article/view/v061i06/v61i06.pdf)\n\n\n\nThere are many libraries and functions in R for performing clustering analysis, so why look at these 2? Well, they solve two important challenges with clustering: visualisation and determining the optimal number of clusters.\n\nIn general, cluster analysis is an unsupervised machine learning task, meaning we don't predefine a target output for the learning. For clustering, this mainly means that we don't know what the categories will be before we start the analysis. We also don't know how many clusters are present. \n\nMany indices have been created to help with determining the optimal number of clusters, however these each have their own advantages and disadvantages and often give conflicting results. We'll demonstrate this by looking at the results from three popular graphical methods: elbow plot, silhouette, and gap statistic. \n\n## Dataset\n\nWe'll be looking at data from the [Soundscape Indices (SSID) Database](https://www.mdpi.com/2076-3417/10/7/2397). This dataset contains data in-situ perceptual assessments of urban soundscapes, paired with acoustic and environmental data. For this set, we'll be looking at the perceptual data only.\n\nTo collect the data, random members of the public were approached while in urban public spaces and asked to take a survey about how they perceive the sound environment. A section of the questions ask specifically about the perceived dominance of sound sources in the space. Sound sources are categorized as Traffic noise, Other noise, Human sounds, Natural sounds, and are rated from 1 [not at all] to 5 [dominates completely].\n\nThe data was collected across 27 locations in the UK, Italy, Spain, the Netherlands, and China. The goal here is to investigate whether these locations can be categorized based on their composition of sound sources.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readxl)\nlibrary(dplyr)  # Data processing and piping\n\n# Clustering libraries\nlibrary(factoextra) # Clustering and visualisation\nlibrary(NbClust)    # Optimal Number of Clusters\nlibrary(RCurl)      # For downloading data from Zenodo\n\ntemp.file <- paste0(tempfile(), \".xlsx\")\ndownload.file(\"https://zenodo.org/record/5705908/files/SSID%20Lockdown%20Database%20VL0.2.2.xlsx\", temp.file, mode=\"wb\")\nssid.data <- read_excel(temp.file)\n\nvars <- c(\"Traffic\", \"Other\", \"Natural\", \"Human\")\n# vars <- c(\"pleasant\", \"chaotic\", \"vibrant\", \"uneventful\", \"calm\", \"annoying\", \"eventful\", \"monotonous\")\n\n# Cutdown the dataset\nssid.data <- ssid.data[c(\"GroupID\", \"SessionID\", \"LocationID\", vars)]\n\n# ssid.data <- subset(ssid.data, Lockdown != 1)\n\n# Set GroupID, SessionID, Location as factor type\nssid.data <- ssid.data %>% mutate_at(vars(GroupID, SessionID, LocationID),\n                                     funs(as.factor))\nssid.data <- ssid.data %>% mutate_at(vars(vars),\n                                     funs(as.numeric))\n\n# Calculate the mean response for each GroupID\nssid.data <- ssid.data %>% \n    group_by(GroupID) %>%\n    summarize(\n              Traffic = mean(Traffic, na.rm=TRUE),\n              Other = mean(Other, na.rm=TRUE),\n              Natural = mean(Natural, na.rm=TRUE),\n              Human = mean(Human, na.rm=TRUE),\n              # pleasant = mean(pleasant, na.rm = TRUE),\n              # chaotic = mean(chaotic, na.rm = TRUE),\n              # vibrant = mean(vibrant, na.rm = TRUE),\n              # uneventful = mean(uneventful, na.rm = TRUE),\n              # calm = mean(calm, na.rm = TRUE),\n              # annoying = mean(annoying, na.rm = TRUE),\n              # eventful = mean(eventful, na.rm = TRUE),\n              # monotonous = mean(monotonous, na.rm = TRUE),\n              LocationID = LocationID[1])\n\n# analysis.data$LocationID <- unique(ssid.data[c('GroupID', 'LocationID')])['LocationID']\nssid.data <- na.omit(ssid.data)\n\nknitr::kable(head(ssid.data))\n```\n\n::: {.cell-output-display}\n|GroupID | Traffic| Other| Natural|    Human|LocationID |\n|:-------|-------:|-----:|-------:|--------:|:----------|\n|AM01    |       1|   3.0|     1.0| 4.000000|SanMarco   |\n|AM02    |       2|   1.5|     3.5| 4.000000|SanMarco   |\n|AM03    |       1|   1.0|     2.0| 4.666667|SanMarco   |\n|AM05    |       2|   2.0|     3.0| 1.000000|SanMarco   |\n|AM06    |       1|   4.0|     1.5| 3.500000|SanMarco   |\n|AM07    |       1|   1.0|     4.0| 4.000000|SanMarco   |\n:::\n:::\n\n\nOur locations are:\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(levels(ssid.data$LocationID))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"CamdenTown\"         \"EustonTap\"          \"MarchmontGarden\"   \n [4] \"MonumentoGaribaldi\" \"PancrasLock\"        \"RegentsParkFields\" \n [7] \"RegentsParkJapan\"   \"RussellSq\"          \"SanMarco\"          \n[10] \"StPaulsCross\"       \"StPaulsRow\"         \"TateModern\"        \n[13] \"TorringtonSq\"      \n```\n:::\n:::\n\n\n## Calculate the mean value for each Location\n**Note:** If the data use different scales, they should always be standardised before clustering. In this case, all of the data are on the same scale, so we don't need to worry.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeans <- aggregate(ssid.data[c(vars)], by=list(ssid.data$LocationID), FUN=mean, na.rm=TRUE)\nmeans <- data.frame(means[, -1], row.names = means[, 1])\n\nknitr::kable(means)\n```\n\n::: {.cell-output-display}\n|                   |  Traffic|    Other|  Natural|    Human|\n|:------------------|--------:|--------:|--------:|--------:|\n|CamdenTown         | 3.787745| 2.652941| 1.316667| 3.219608|\n|EustonTap          | 3.717857| 2.858929| 1.642262| 2.515476|\n|MarchmontGarden    | 2.663542| 2.412500| 2.564583| 2.695833|\n|MonumentoGaribaldi | 1.903509| 1.885965| 2.982456| 3.254386|\n|PancrasLock        | 2.457500| 3.144167| 2.391667| 2.453333|\n|RegentsParkFields  | 2.422886| 1.911692| 3.148010| 2.866915|\n|RegentsParkJapan   | 1.867179| 1.528718| 3.974103| 2.450000|\n|RussellSq          | 2.668120| 2.027132| 3.334302| 2.987403|\n|SanMarco           | 1.431852| 1.895926| 2.230370| 4.041852|\n|StPaulsCross       | 2.503704| 2.000000| 2.266667| 3.311111|\n|StPaulsRow         | 2.527132| 2.294574| 1.744186| 3.368217|\n|TateModern         | 2.541667| 2.150833| 2.598333| 3.660833|\n|TorringtonSq       | 3.230676| 2.848068| 1.957005| 3.269565|\n:::\n:::\n\n\n\n## Clustering Analysis\n\n### Some standard, single indices\n\nElbow plot (within-sum-of-squares), Silhouette, Gap statistic\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nfviz_nbclust(means, hcut, method=\"wss\", ggtheme = theme_bw())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code}\nfviz_nbclust(means, hcut, method=\"silhouette\", ggtheme = theme_bw())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-2.png){width=672}\n:::\n\n```{.r .cell-code}\nfviz_nbclust(means, hcut, method=\"gap_stat\", ggtheme=theme_bw())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-3.png){width=672}\n:::\n:::\n\n\nAs we can see, it can be less than obvious how to interpret some of these - where exactly is the 'elbow' in the elbow plot? Silhouette pretty clearly says k = 2, but the Gap stat gives k = 1, which isn't very useful. How do we know which is right?\n\n### 30 indices using NbClust\nNbClust \n\n\n::: {.cell}\n\n```{.r .cell-code}\nindices = c(\"kl\", \"ch\", \"ccc\", \"cindex\", \"db\", \"silhouette\", \"duda\", \"pseudot2\", \"ratkowsky\", \"ptbiserial\", \"gap\", \"mcclain\", \"gamma\", \"gplus\", \"tau\",\"sdindex\", \"sdbw\")\nres <- NbClust(data = means, distance='euclidean', min.nc = 2, max.nc=9, method=\"ward.D2\", index = \"alllong\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in pf(beale, pp, df2): NaNs produced\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n*** : The Hubert index is a graphical method of determining the number of clusters.\n                In the plot of Hubert index, we seek a significant knee that corresponds to a \n                significant increase of the value of the measure i.e the significant peak in Hubert\n                index second differences plot. \n \n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-2.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n*** : The D index is a graphical method of determining the number of clusters. \n                In the plot of D index, we seek a significant knee (the significant peak in Dindex\n                second differences plot) that corresponds to a significant increase of the value of\n                the measure. \n \n******************************************************************* \n* Among all indices:                                                \n* 9 proposed 2 as the best number of clusters \n* 4 proposed 3 as the best number of clusters \n* 2 proposed 4 as the best number of clusters \n* 1 proposed 5 as the best number of clusters \n* 4 proposed 6 as the best number of clusters \n* 1 proposed 7 as the best number of clusters \n* 2 proposed 8 as the best number of clusters \n* 5 proposed 9 as the best number of clusters \n\n                   ***** Conclusion *****                            \n \n* According to the majority rule, the best number of clusters is  2 \n \n \n******************************************************************* \n```\n:::\n\n```{.r .cell-code}\nknitr::kable(res)\n```\n\n::: {.cell-output-display}\n<table class=\"kable_wrapper\">\n<tbody>\n  <tr>\n   <td> \n\n|   |     KL|      CH| Hartigan|    CCC|    Scott| Marriot|  TrCovW|  TraceW|  Friedman|    Rubin| Cindex|     DB| Silhouette|   Duda| Pseudot2|   Beale| Ratkowsky|   Ball| Ptbiserial|     Gap|   Frey| McClain|  Gamma|  Gplus|     Tau|   Dunn| Hubert| SDindex| Dindex|   SDbw|\n|:--|------:|-------:|--------:|------:|--------:|-------:|-------:|-------:|---------:|--------:|------:|------:|----------:|------:|--------:|-------:|---------:|------:|----------:|-------:|------:|-------:|------:|------:|-------:|------:|------:|-------:|------:|------:|\n|2  | 1.0970|  8.1449|   6.0597| 7.5851| 102.6537| 30.2615| 13.4952| 10.1742|  351.3546|  36.9377| 0.4269| 0.8174|     0.3529| 0.6156|   4.9946|  1.3398|    0.3840| 5.0871|     0.5020| -0.9326| 1.0370|  0.4096| 0.5903| 3.7821| 10.8974| 0.3539| 0.0753|  2.5622| 0.8042| 0.4459|\n|3  | 1.1005|  8.4961|   5.2330| 6.3990| 119.6026| 18.4865|  5.5195|  6.5603|  404.1006|  57.2860| 0.3951| 1.0948|     0.2818| 0.4299|   5.3038|  2.5609|    0.4103| 2.1868|     0.4710| -1.6230| 0.2765|  1.3913| 0.6265| 3.1026| 10.4103| 0.3626| 0.0800|  2.8643| 0.6523| 0.3387|\n|4  | 1.6303|  9.3352|   3.5123| 5.9285| 136.6838|  8.8328|  2.0114|  4.3066|  514.5025|  87.2635| 0.5492| 0.8335|     0.3286| 2.5977|  -1.2301| -0.9899|    0.4303| 1.0767|     0.4840| -1.8404| 0.2171|  2.0924| 0.7560| 1.5513|  9.6154| 0.5689| 0.0773|  2.4025| 0.5465| 0.2559|\n|5  | 0.8819|  9.4327|   4.1056| 5.4008| 150.1412|  4.9017|  0.9988|  3.0977|  615.3276| 121.3182| 0.5171| 0.6492|     0.4032| 2.6324|  -1.2402| -0.9981|    0.4026| 0.6195|     0.4854| -2.3510| 0.1834|  2.4726| 0.8391| 0.8718|  9.0897| 0.6139| 0.0863|  2.3482| 0.4455| 0.1689|\n|6  | 2.4474| 10.7100|   1.9565| 5.2900| 170.5431|  1.4694|  0.3679|  2.0471|  969.8285| 183.5792| 0.5973| 0.5852|     0.4719| 1.8668|  -0.4643| -0.5605|    0.3812| 0.3412|     0.4830| -2.4797| 0.5241|  2.9403| 0.9529| 0.2051|  8.3077| 0.8559| 0.1062|  2.4432| 0.3528| 0.1185|\n|7  | 0.9458| 10.0676|   1.9696| 4.5460| 183.1309|  0.7595|  0.2213|  1.5999| 1194.4928| 234.8889| 0.5305| 0.5508|     0.4589| 3.4939|  -0.7138| -0.8616|    0.3578| 0.2286|     0.4476| -2.9193| 0.8670|  3.6092| 0.9643| 0.1282|  6.9231| 0.8905| 0.1153|  3.0849| 0.2980| 0.0970|\n|8  | 0.9554|  9.7863|   2.1072| 4.5678| 213.5276|  0.0957|  0.1542|  1.2045| 3652.8265| 311.9964| 0.4860| 0.4826|     0.5005| 3.0804|  -0.6754| -0.8152|    0.3386| 0.1506|     0.3947| -3.0908| 0.5258|  4.8153| 0.9537| 0.1282|  5.2821| 0.7320| 0.1161|  3.2357| 0.2402| 0.0697|\n|9  | 0.9437|  9.9481|   2.5926| 3.7773| 235.4352|  0.0225|  0.0873|  0.8474| 6052.3637| 443.4830| 0.4147| 0.4100|     0.5619| 4.7507|   0.0000|  0.0000|    0.3219| 0.0942|     0.3339| -3.4867| 0.1666|  7.0102| 0.9662| 0.0641|  3.6667| 0.7386| 0.1163|  3.4232| 0.1907| 0.0490|\n\n </td>\n   <td> \n\n|   | CritValue_Duda| CritValue_PseudoT2| Fvalue_Beale| CritValue_Gap|\n|:--|--------------:|------------------:|------------:|-------------:|\n|2  |         0.2019|            31.6230|       0.2766|        0.7534|\n|3  |         0.0160|           246.4030|       0.0787|        0.2949|\n|4  |        -0.1694|           -13.8056|       1.0000|        0.6048|\n|5  |        -0.1694|           -13.8056|       1.0000|        0.2346|\n|6  |        -0.3257|            -4.0703|       1.0000|        0.5672|\n|7  |        -0.3257|            -4.0703|       1.0000|        0.3163|\n|8  |        -0.3257|            -4.0703|       1.0000|        0.5663|\n|9  |        -0.5879|             0.0000|          NaN|        0.3864|\n\n </td>\n   <td> \n\n|                |     KL|    CH| Hartigan|    CCC|   Scott| Marriot| TrCovW| TraceW| Friedman|    Rubin| Cindex|   DB| Silhouette|   Duda| PseudoT2|  Beale| Ratkowsky|   Ball| PtBiserial|     Gap|  Frey| McClain|  Gamma|  Gplus|     Tau|   Dunn| Hubert| SDindex| Dindex|  SDbw|\n|:---------------|------:|-----:|--------:|------:|-------:|-------:|------:|------:|--------:|--------:|------:|----:|----------:|------:|--------:|------:|---------:|------:|----------:|-------:|-----:|-------:|------:|------:|-------:|------:|------:|-------:|------:|-----:|\n|Number_clusters | 6.0000|  6.00|   6.0000| 2.0000|  8.0000|  4.0000| 3.0000| 3.0000|    8.000|   6.0000| 3.0000| 9.00|     9.0000| 2.0000|   2.0000| 2.0000|    4.0000| 3.0000|      2.000|  2.0000| 2.000|  2.0000| 9.0000| 9.0000|  2.0000| 7.0000|      0|  5.0000|      0| 9.000|\n|Value_Index     | 2.4474| 10.71|   2.1492| 7.5851| 30.3968|  5.7226| 7.9756| 1.3603| 2458.334| -10.9512| 0.3951| 0.41|     0.5619| 0.6156|   4.9946| 1.3398|    0.4303| 2.9003|      0.502| -0.9326| 1.037|  0.4096| 0.9662| 0.0641| 10.8974| 0.8905|      0|  2.3482|      0| 0.049|\n\n </td>\n   <td> \n\n|                   |  x|\n|:------------------|--:|\n|CamdenTown         |  1|\n|EustonTap          |  1|\n|MarchmontGarden    |  2|\n|MonumentoGaribaldi |  2|\n|PancrasLock        |  2|\n|RegentsParkFields  |  2|\n|RegentsParkJapan   |  2|\n|RussellSq          |  2|\n|SanMarco           |  2|\n|StPaulsCross       |  2|\n|StPaulsRow         |  2|\n|TateModern         |  2|\n|TorringtonSq       |  1|\n\n </td>\n  </tr>\n</tbody>\n</table>\n:::\n\n```{.r .cell-code}\nfviz_nbclust(res)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in if (class(best_nc) == \"numeric\") print(best_nc) else if (class(best_nc) == : the condition has length > 1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nk = 2\nk.fit <- kmeans(means, k)\nknitr::kable(k.fit)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in as.data.frame.default(x): cannot coerce class '\"kmeans\"' to a data.frame\n```\n:::\n\n```{.r .cell-code}\nfviz_cluster(k.fit, means, repel=TRUE, ggtheme = theme_bw())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres.pca <- prcomp(means, scale=TRUE)\nfacto_summarize(res.pca, \"var\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           name      Dim.1      Dim.2     coord      cos2  contrib\nTraffic Traffic -0.8891690 -0.1531570 0.8140785 0.8140785 22.70701\nOther     Other -0.9153206 -0.1088317 0.8496561 0.8496561 23.69937\nNatural Natural  0.8316428 -0.5046107 0.9462617 0.9462617 26.39398\nHuman     Human  0.1897201  0.9690987 0.9751460 0.9751460 27.19965\n```\n:::\n\n```{.r .cell-code}\nfviz_contrib(res.pca, \"var\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfit <- eclust(means, \"kmeans\", k=k)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nh.fit <- eclust(means, \"hclust\", k=k, stand = T, hc_method = \"ward.D2\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The `<scale>` argument of `guides()` cannot be `FALSE`. Use \"none\" instead as\nof ggplot2 3.3.4.\nℹ The deprecated feature was likely used in the factoextra package.\n  Please report the issue at <https://github.com/kassambara/factoextra/issues>.\n```\n:::\n\n```{.r .cell-code}\nfviz_dend(h.fit, labels_track_height = 2.5, horiz=TRUE, rect = TRUE, cex = 0.5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n## Methods I haven't really tested out thoroughly\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfviz_pca_biplot(res.pca, repel=T,ggtheme = theme_bw())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n### `fviz_silhouette()`\n\nSilhouette (Si) analysis is a cluster validation approach that measures how well an observation is clustered and it estimates the average distance between clusters. \n\n**Details**\n\n * Observations with a large silhouette Si (almost 1) are very well clustered\n * A small Si (around 0) means that the observation lies between two clusters\n * Observations with a negative Si are probably placed in the wrong cluster\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfviz_silhouette(h.fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  cluster size ave.sil.width\n1       1    5          0.32\n2       2    8          0.32\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n### `get_clust_tendency`\n\nBefore applying cluster methods, the first step is to assess whether the data is clusterable, a process defined as the **assessing of clustering tendency**. `get_clust_tendency()` assesses clustering tendency using Hopkins' statistic and a visual approach. \n\n**Details**\n\n**Hopkins Statistic:** If the value of Hopkins statistic is close to 1 (far above 0.5), then we can conclude that the dataset is significantly clusterable.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n$hopkins_stat\n[1] 0.6977892\n\n$plot\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}