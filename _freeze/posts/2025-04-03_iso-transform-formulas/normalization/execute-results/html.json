{
  "hash": "f06dc1d7d30ec721c224846a595b65ad",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"A Robust Normalization Approach for Soundscape Circumplex Coordinates\"\nformat: html\njupyter: python3\n---\n\n\n## Introduction\n\nThe ISO 12913 series provides standardized methods for soundscape assessment, establishing a framework for measuring perceptual responses to acoustic environments. When adapting these methods to different languages and cultural contexts, issues can arise with the normalization factors that ensure coordinates remain within the desired [-1, +1] range. This document presents a mathematical solution to this problem, deriving a generalized formulation that works for any arrangement of attributes around the circumplex.\n\n## The Problem with Existing Approaches\n\nThe generalized formulation originally developed in the Soundscape Attributes Translation Project (SATP) has limitations when applied to non-equally spaced angles. Monte Carlo simulations show this approach does not guarantee coordinates will remain within the [-1, +1] range for all possible angle distributions and score combinations.\n\n::: {#e67c1962 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n```\n:::\n\n\n## A First-Principles Approach to Normalization\n\nTo derive a robust normalization method, we need to consider:\n1. The maximum and minimum possible values when scores range from 1 to 5\n2. The proper centering to ensure neutral scores (all 3s) map to (0,0)\n3. The appropriate scaling to ensure the full range maps to [-1, +1]\n\n### Deriving the Maximum and Minimum Values\n\nFor the pleasantness dimension, the raw sum is:\n$$P_{raw} = \\sum_{i=1}^{8}\\cos(\\theta_i) \\times \\sigma_i$$\n\nThe maximum value occurs when:\n- Maximum score (5) is assigned to attributes with positive cosine (cos(θᵢ) > 0)\n- Minimum score (1) is assigned to attributes with negative cosine (cos(θᵢ) < 0)\n\nThis gives:\n$$P_{max} = 5 \\times \\sum\\max(0, \\cos(\\theta_i)) + 1 \\times \\sum\\min(0, \\cos(\\theta_i))$$\n\nUsing the identity $\\sum\\min(0, \\cos(\\theta_i)) = -\\sum\\max(0, -\\cos(\\theta_i))$:\n$$P_{max} = 5 \\times \\sum\\max(0, \\cos(\\theta_i)) - 1 \\times \\sum\\max(0, -\\cos(\\theta_i))$$\n\nSimilarly, the minimum value is:\n$$P_{min} = 1 \\times \\sum\\max(0, \\cos(\\theta_i)) - 5 \\times \\sum\\max(0, -\\cos(\\theta_i))$$\n\n### Accounting for Neutral Scores\n\nFor neutral scores (all σᵢ = 3), we get:\n$$P_{neutral} = 3 \\times \\sum\\cos(\\theta_i)$$\n\nThis is zero only when $\\sum\\cos(\\theta_i) = 0$, which is true for evenly-spaced angles but not generally.\n\n### The Complete Transformation\n\nTo map [P_min, P_max] to [-1, +1] while ensuring neutral scores map to 0:\n\n1. Center the values around the neutral point:\n$$P_{centered} = P_{raw} - 3 \\times \\sum\\cos(\\theta_i) = \\sum(\\cos(\\theta_i) \\times (\\sigma_i - 3))$$\n\n2. Find the maximum and minimum of the centered values:\n$$P_{max\\_centered} = 2 \\times \\sum\\max(0, \\cos(\\theta_i)) + 2 \\times \\sum\\max(0, -\\cos(\\theta_i))$$\n$$P_{min\\_centered} = -2 \\times (\\sum\\max(0, \\cos(\\theta_i)) + \\sum\\max(0, -\\cos(\\theta_i)))$$\n\n3. The range is:\n$$Range = P_{max\\_centered} - P_{min\\_centered} = 4 \\times (\\sum\\max(0, \\cos(\\theta_i)) + \\sum\\max(0, -\\cos(\\theta_i)))$$\n\n4. Normalize by dividing by half the range:\n$$P_{ISO} = \\frac{P_{centered}}{Range/2} = \\frac{P_{raw} - 3 \\times \\sum\\cos(\\theta_i)}{2 \\times (\\sum\\max(0, \\cos(\\theta_i)) + \\sum\\max(0, -\\cos(\\theta_i)))}$$\n\n## The Correctly Formulated Equations\n\nFor pleasantness:\n$$P_{ISO} = \\frac{\\sum(\\cos(\\theta_i) \\times \\sigma_i) - 3 \\times \\sum\\cos(\\theta_i)}{2 \\times (\\sum\\max(0, \\cos(\\theta_i)) + \\sum\\max(0, -\\cos(\\theta_i)))}$$\n\nFor eventfulness:\n$$E_{ISO} = \\frac{\\sum(\\sin(\\theta_i) \\times \\sigma_i) - 3 \\times \\sum\\sin(\\theta_i)}{2 \\times (\\sum\\max(0, \\sin(\\theta_i)) + \\sum\\max(0, -\\sin(\\theta_i)))}$$\n\nLet's implement these formulas and test them:\n\n::: {#ba49d014 .cell execution_count=2}\n``` {.python .cell-code}\n# Function to calculate the correct ISO coordinates\ndef correct_iso_coordinates(angles, scores):\n    \"\"\"\n    Calculate ISO Pleasant and ISO Eventful using the correctly formulated equations\n\n    Parameters:\n    angles (array): Array of angles in degrees for the 8 scales\n    scores (array): Array of scores for each scale (1-5)\n\n    Returns:\n    tuple: (ISO Pleasant, ISO Eventful) coordinates\n    \"\"\"\n    angles_rad = np.radians(angles)\n\n    # Calculate cosine and sine values\n    cos_values = np.cos(angles_rad)\n    sin_values = np.sin(angles_rad)\n\n    # Calculate components for pleasantness\n    cos_sum = np.sum(cos_values)\n    p_raw = np.sum(cos_values * scores)\n    cos_pos_sum = np.sum(np.maximum(0, cos_values))\n    cos_neg_sum = np.sum(np.maximum(0, -cos_values))\n\n    # Calculate components for eventfulness\n    sin_sum = np.sum(sin_values)\n    e_raw = np.sum(sin_values * scores)\n    sin_pos_sum = np.sum(np.maximum(0, sin_values))\n    sin_neg_sum = np.sum(np.maximum(0, -sin_values))\n\n    # Calculate ISO coordinates using the correct formula\n    p_iso = (p_raw - 3 * cos_sum) / (2 * (cos_pos_sum + cos_neg_sum))\n    e_iso = (e_raw - 3 * sin_sum) / (2 * (sin_pos_sum + sin_neg_sum))\n\n    return (p_iso, e_iso)\n\n\n# Original approach for comparison\ndef original_iso_coordinates(angles, scores, rho=4):\n    \"\"\"\n    Calculate ISO coordinates using the original approach\n\n    Parameters:\n    angles (array): Array of angles in degrees for the 8 scales\n    scores (array): Array of scores for each scale (1-5)\n    rho (float): Range of possible response values\n\n    Returns:\n    tuple: (ISO Pleasant, ISO Eventful) coordinates\n    \"\"\"\n    angles_rad = np.radians(angles)\n\n    # Numerators\n    numerator_pleasant = np.sum(np.cos(angles_rad) * scores)\n    numerator_eventful = np.sum(np.sin(angles_rad) * scores)\n\n    # Denominators (lambda values)\n    denominator_pleasant = (rho / 2) * np.sum(np.abs(np.cos(angles_rad)))\n    denominator_eventful = (rho / 2) * np.sum(np.abs(np.sin(angles_rad)))\n\n    return (\n        numerator_pleasant / denominator_pleasant,\n        numerator_eventful / denominator_eventful,\n    )\n\n\n# Refined approach from SATP for comparison\ndef refined_iso_coordinates(angles, scores, rho=4):\n    \"\"\"\n    Calculate ISO coordinates using the refined approach from SATP\n\n    Parameters:\n    angles (array): Array of angles in degrees for the 8 scales\n    scores (array): Array of scores for each scale (1-5)\n    rho (float): Range of possible response values\n\n    Returns:\n    tuple: (ISO Pleasant, ISO Eventful) coordinates\n    \"\"\"\n    angles_rad = np.radians(angles)\n\n    # Numerators\n    numerator_pleasant = np.sum(np.cos(angles_rad) * scores)\n    numerator_eventful = np.sum(np.sin(angles_rad) * scores)\n\n    # Denominators (lambda values)\n    denominator_pleasant = rho * np.sum(np.maximum(0, np.cos(angles_rad)))\n    denominator_eventful = rho * np.sum(np.maximum(0, np.sin(angles_rad)))\n\n    return (\n        numerator_pleasant / denominator_pleasant,\n        numerator_eventful / denominator_eventful,\n    )\n```\n:::\n\n\n## Testing with Evenly Spaced Angles\n\nLet's first verify that our formulation works correctly with the standard evenly spaced angles:\n\n::: {#72e74b70 .cell execution_count=3}\n``` {.python .cell-code}\n# Standard equally spaced angles (45° increments)\nequal_angles = np.array([0, 45, 90, 135, 180, 225, 270, 315])\n\n# Tests with different score patterns\ntest_cases = [\n    {\"name\": \"All neutral (3)\", \"scores\": np.array([3, 3, 3, 3, 3, 3, 3, 3])},\n    {\"name\": \"Maximum pleasant\", \"scores\": np.array([5, 5, 3, 1, 1, 1, 3, 5])},\n    {\"name\": \"Maximum unpleasant\", \"scores\": np.array([1, 1, 3, 5, 5, 5, 3, 1])},\n    {\"name\": \"Maximum eventful\", \"scores\": np.array([3, 5, 5, 5, 3, 1, 1, 1])},\n    {\"name\": \"Maximum uneventful\", \"scores\": np.array([3, 1, 1, 1, 3, 5, 5, 5])}\n]\n\nprint(\"Tests with evenly spaced angles:\")\nfor case in test_cases:\n    # Calculate using the three approaches\n    correct = correct_iso_coordinates(equal_angles, case[\"scores\"])\n    original = original_iso_coordinates(equal_angles, case[\"scores\"])\n    refined = refined_iso_coordinates(equal_angles, case[\"scores\"])\n    \n    print(f\"\\n{case['name']}:\")\n    print(f\"Correct formula: (P={correct[0]:.4f}, E={correct[1]:.4f})\")\n    print(f\"Original approach: (P={original[0]:.4f}, E={original[1]:.4f})\")\n    print(f\"Refined approach: (P={refined[0]:.4f}, E={refined[1]:.4f})\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTests with evenly spaced angles:\n\nAll neutral (3):\nCorrect formula: (P=0.0000, E=0.0000)\nOriginal approach: (P=-0.0000, E=0.0000)\nRefined approach: (P=-0.0000, E=0.0000)\n\nMaximum pleasant:\nCorrect formula: (P=1.0000, E=-0.0000)\nOriginal approach: (P=1.0000, E=-0.0000)\nRefined approach: (P=1.0000, E=-0.0000)\n\nMaximum unpleasant:\nCorrect formula: (P=-1.0000, E=0.0000)\nOriginal approach: (P=-1.0000, E=0.0000)\nRefined approach: (P=-1.0000, E=0.0000)\n\nMaximum eventful:\nCorrect formula: (P=0.0000, E=1.0000)\nOriginal approach: (P=0.0000, E=1.0000)\nRefined approach: (P=0.0000, E=1.0000)\n\nMaximum uneventful:\nCorrect formula: (P=-0.0000, E=-1.0000)\nOriginal approach: (P=-0.0000, E=-1.0000)\nRefined approach: (P=-0.0000, E=-1.0000)\n```\n:::\n:::\n\n\n## Testing with Non-Equally Spaced Angles\n\nNow let's test with a non-equally spaced angle configuration:\n\n::: {#2d6ac0ba .cell execution_count=4}\n``` {.python .cell-code}\n# Example from a non-English language translation\nnon_equal_angles = np.array([0, 53, 104, 123, 139, 202, 284, 308])\n\nprint(\"\\nTests with non-equally spaced angles:\")\nfor case in test_cases:\n    # Calculate using the three approaches\n    correct = correct_iso_coordinates(non_equal_angles, case[\"scores\"])\n    original = original_iso_coordinates(non_equal_angles, case[\"scores\"])\n    refined = refined_iso_coordinates(non_equal_angles, case[\"scores\"])\n    \n    print(f\"\\n{case['name']}:\")\n    print(f\"Correct formula: (P={correct[0]:.4f}, E={correct[1]:.4f})\")\n    print(f\"Original approach: (P={original[0]:.4f}, E={original[1]:.4f})\")\n    print(f\"Refined approach: (P={refined[0]:.4f}, E={refined[1]:.4f})\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nTests with non-equally spaced angles:\n\nAll neutral (3):\nCorrect formula: (P=0.0000, E=0.0000)\nOriginal approach: (P=-0.0028, E=0.3143)\nRefined approach: (P=-0.0028, E=0.2598)\n\nMaximum pleasant:\nCorrect formula: (P=0.9018, E=-0.2056)\nOriginal approach: (P=0.8991, E=0.1087)\nRefined approach: (P=0.9007, E=0.0899)\n\nMaximum unpleasant:\nCorrect formula: (P=-0.9018, E=0.2056)\nOriginal approach: (P=-0.9046, E=0.5199)\nRefined approach: (P=-0.9062, E=0.4298)\n\nMaximum eventful:\nCorrect formula: (P=-0.0234, E=0.8784)\nOriginal approach: (P=-0.0261, E=1.1927)\nRefined approach: (P=-0.0262, E=0.9861)\n\nMaximum uneventful:\nCorrect formula: (P=0.0234, E=-0.8784)\nOriginal approach: (P=0.0206, E=-0.5641)\nRefined approach: (P=0.0206, E=-0.4664)\n```\n:::\n:::\n\n\n## Monte Carlo Simulation to Verify Correctness\n\nNow let's run a comprehensive Monte Carlo simulation to verify that our formulation guarantees coordinates within the [-1, +1] range for all possible angle distributions and score combinations:\n\n::: {#9ed03e38 .cell execution_count=5}\n``` {.python .cell-code}\ndef run_monte_carlo_simulation(num_iterations=5000):\n    \"\"\"\n    Run a Monte Carlo simulation to verify that coordinates always fall within [-1, +1] range\n    \n    Parameters:\n    num_iterations (int): Number of simulation iterations\n    \n    Returns:\n    dict: Dictionary with simulation results\n    \"\"\"\n    # Storage for results\n    results = {\n        'original_pleasant': [],\n        'original_eventful': [],\n        'refined_pleasant': [],\n        'refined_eventful': [],\n        'correct_pleasant': [],\n        'correct_eventful': [],\n        'original_out_of_range': 0,\n        'refined_out_of_range': 0,\n        'correct_out_of_range': 0\n    }\n    \n    for _ in range(num_iterations):\n        # Generate random angles (8 angles between 0 and 360)\n        angles = np.random.uniform(0, 360, 8)\n        \n        # Generate random scores (8 scores between 1 and 5)\n        scores = np.random.uniform(1, 5, 8)\n        \n        # Calculate ISO coordinates with all three methods\n        orig_coords = original_iso_coordinates(angles, scores)\n        refined_coords = refined_iso_coordinates(angles, scores)\n        correct_coords = correct_iso_coordinates(angles, scores)\n        \n        # Store results\n        results['original_pleasant'].append(orig_coords[0])\n        results['original_eventful'].append(orig_coords[1])\n        results['refined_pleasant'].append(refined_coords[0])\n        results['refined_eventful'].append(refined_coords[1])\n        results['correct_pleasant'].append(correct_coords[0])\n        results['correct_eventful'].append(correct_coords[1])\n        \n        # Check if any coordinates are out of range\n        if abs(orig_coords[0]) > 1 or abs(orig_coords[1]) > 1:\n            results['original_out_of_range'] += 1\n        \n        if abs(refined_coords[0]) > 1 or abs(refined_coords[1]) > 1:\n            results['refined_out_of_range'] += 1\n        \n        if abs(correct_coords[0]) > 1 or abs(correct_coords[1]) > 1:\n            results['correct_out_of_range'] += 1\n    \n    return results\n\n# Run simulation\nnp.random.seed(42)  # For reproducibility\nsim_results = run_monte_carlo_simulation(5000)\n\n# Report results\nprint(\"\\nMonte Carlo Simulation Results (5000 iterations):\")\nprint(f\"Original approach out-of-range instances: {sim_results['original_out_of_range']} ({sim_results['original_out_of_range']/50:.2f}%)\")\nprint(f\"Refined approach out-of-range instances: {sim_results['refined_out_of_range']} ({sim_results['refined_out_of_range']/50:.2f}%)\")\nprint(f\"Correct formula out-of-range instances: {sim_results['correct_out_of_range']} ({sim_results['correct_out_of_range']/50:.2f}%)\")\n\n# Visualize the results\nfig, axes = plt.subplots(1, 3, figsize=(18, 6))\n\n# Plot original approach results\nscatter1 = axes[0].scatter(sim_results['original_pleasant'], sim_results['original_eventful'], \n                          alpha=0.3, s=5, c=np.abs(np.array(sim_results['original_pleasant'])) + np.abs(np.array(sim_results['original_eventful'])))\naxes[0].set_xlim(-1.5, 1.5)\naxes[0].set_ylim(-1.5, 1.5)\naxes[0].axhline(y=0, color='k', linestyle='-', alpha=0.2)\naxes[0].axvline(x=0, color='k', linestyle='-', alpha=0.2)\naxes[0].grid(alpha=0.2)\naxes[0].set_title('Original ISO Approach')\naxes[0].set_xlabel('ISO Pleasant')\naxes[0].set_ylabel('ISO Eventful')\n\n# Draw circle boundary at radius 1\ncircle1 = plt.Circle((0, 0), 1, fill=False, linestyle='-', color='red', alpha=0.7)\naxes[0].add_patch(circle1)\n\n# Plot refined approach results\nscatter2 = axes[1].scatter(sim_results['refined_pleasant'], sim_results['refined_eventful'], \n                          alpha=0.3, s=5, c=np.abs(np.array(sim_results['refined_pleasant'])) + np.abs(np.array(sim_results['refined_eventful'])))\naxes[1].set_xlim(-1.5, 1.5)\naxes[1].set_ylim(-1.5, 1.5)\naxes[1].axhline(y=0, color='k', linestyle='-', alpha=0.2)\naxes[1].axvline(x=0, color='k', linestyle='-', alpha=0.2)\naxes[1].grid(alpha=0.2)\naxes[1].set_title('Refined SATP Approach')\naxes[1].set_xlabel('ISO Pleasant')\naxes[1].set_ylabel('ISO Eventful')\n\n# Draw circle boundary at radius 1\ncircle2 = plt.Circle((0, 0), 1, fill=False, linestyle='-', color='red', alpha=0.7)\naxes[1].add_patch(circle2)\n\n# Plot correct approach results\nscatter3 = axes[2].scatter(sim_results['correct_pleasant'], sim_results['correct_eventful'], \n                          alpha=0.3, s=5, c=np.abs(np.array(sim_results['correct_pleasant'])) + np.abs(np.array(sim_results['correct_eventful'])))\naxes[2].set_xlim(-1.5, 1.5)\naxes[2].set_ylim(-1.5, 1.5)\naxes[2].axhline(y=0, color='k', linestyle='-', alpha=0.2)\naxes[2].axvline(x=0, color='k', linestyle='-', alpha=0.2)\naxes[2].grid(alpha=0.2)\naxes[2].set_title('Correct Normalization Approach')\naxes[2].set_xlabel('ISO Pleasant')\naxes[2].set_ylabel('ISO Eventful')\n\n# Draw circle boundary at radius 1\ncircle3 = plt.Circle((0, 0), 1, fill=False, linestyle='-', color='red', alpha=0.7)\naxes[2].add_patch(circle3)\n\n# Add colorbars\nplt.colorbar(scatter1, ax=axes[0], label='Distance from origin')\nplt.colorbar(scatter2, ax=axes[1], label='Distance from origin')\nplt.colorbar(scatter3, ax=axes[2], label='Distance from origin')\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nMonte Carlo Simulation Results (5000 iterations):\nOriginal approach out-of-range instances: 1087 (21.74%)\nRefined approach out-of-range instances: 1509 (30.18%)\nCorrect formula out-of-range instances: 0 (0.00%)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n/var/folders/6t/7h8wn9n92w5f24ml_bkwck9m0000gn/T/ipykernel_65028/2522861559.py:92: RuntimeWarning:\n\ndivide by zero encountered in scalar divide\n\n/var/folders/6t/7h8wn9n92w5f24ml_bkwck9m0000gn/T/ipykernel_65028/2522861559.py:91: RuntimeWarning:\n\ndivide by zero encountered in scalar divide\n\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](normalization_files/figure-html/cell-6-output-3.png){width=1709 height=566}\n:::\n:::\n\n\n## Testing Extreme Values\n\nTo further validate our approach, let's test with extreme score combinations:\n\n::: {#9423d298 .cell execution_count=6}\n``` {.python .cell-code}\ndef verify_extreme_scores(angles):\n    \"\"\"\n    Verify that extreme score combinations map correctly to the boundaries\n    \n    Parameters:\n    angles (array): Array of angles in degrees for the 8 scales\n    \"\"\"\n    # Convert angles to radians\n    angles_rad = np.radians(angles)\n    \n    # Calculate cosine and sine values\n    cos_values = np.cos(angles_rad)\n    sin_values = np.sin(angles_rad)\n    \n    # Determine which angles have positive and negative cosine/sine values\n    cos_pos_mask = cos_values > 0\n    cos_neg_mask = cos_values < 0\n    sin_pos_mask = sin_values > 0\n    sin_neg_mask = sin_values < 0\n    \n    # Create extreme score combinations\n    max_pleasant_scores = np.ones(len(angles)) * 3  # Start with neutral\n    max_pleasant_scores[cos_pos_mask] = 5  # Max score for positive cosine\n    max_pleasant_scores[cos_neg_mask] = 1  # Min score for negative cosine\n    \n    min_pleasant_scores = np.ones(len(angles)) * 3  # Start with neutral\n    min_pleasant_scores[cos_pos_mask] = 1  # Min score for positive cosine\n    min_pleasant_scores[cos_neg_mask] = 5  # Max score for negative cosine\n    \n    max_eventful_scores = np.ones(len(angles)) * 3  # Start with neutral\n    max_eventful_scores[sin_pos_mask] = 5  # Max score for positive sine\n    max_eventful_scores[sin_neg_mask] = 1  # Min score for negative sine\n    \n    min_eventful_scores = np.ones(len(angles)) * 3  # Start with neutral\n    min_eventful_scores[sin_pos_mask] = 1  # Min score for positive sine\n    min_eventful_scores[sin_neg_mask] = 5  # Max score for negative sine\n    \n    # Calculate coordinates for extreme cases\n    max_pleasant = correct_iso_coordinates(angles, max_pleasant_scores)\n    min_pleasant = correct_iso_coordinates(angles, min_pleasant_scores)\n    max_eventful = correct_iso_coordinates(angles, max_eventful_scores)\n    min_eventful = correct_iso_coordinates(angles, min_eventful_scores)\n    neutral = correct_iso_coordinates(angles, np.ones(len(angles)) * 3)\n    \n    # Print results\n    print(f\"Neutral scores: (P={neutral[0]:.4f}, E={neutral[1]:.4f})\")\n    print(f\"Max pleasant scores: (P={max_pleasant[0]:.4f}, E={max_pleasant[1]:.4f})\")\n    print(f\"Min pleasant scores: (P={min_pleasant[0]:.4f}, E={min_pleasant[1]:.4f})\")\n    print(f\"Max eventful scores: (P={max_eventful[0]:.4f}, E={max_eventful[1]:.4f})\")\n    print(f\"Min eventful scores: (P={min_eventful[0]:.4f}, E={min_eventful[1]:.4f})\")\n\n# Test with evenly spaced angles\nprint(\"Extreme score test with evenly spaced angles:\")\nverify_extreme_scores(equal_angles)\n\n# Test with non-equally spaced angles\nprint(\"\\nExtreme score test with non-equally spaced angles:\")\nverify_extreme_scores(non_equal_angles)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExtreme score test with evenly spaced angles:\nNeutral scores: (P=0.0000, E=0.0000)\nMax pleasant scores: (P=1.0000, E=0.4142)\nMin pleasant scores: (P=-1.0000, E=-0.4142)\nMax eventful scores: (P=-0.2071, E=1.0000)\nMin eventful scores: (P=0.2071, E=-1.0000)\n\nExtreme score test with non-equally spaced angles:\nNeutral scores: (P=0.0000, E=0.0000)\nMax pleasant scores: (P=1.0000, E=-0.5652)\nMin pleasant scores: (P=-1.0000, E=0.5652)\nMax eventful scores: (P=-0.1765, E=1.0000)\nMin eventful scores: (P=0.1765, E=-1.0000)\n```\n:::\n:::\n\n\n## Comparison with a Completely Random Configuration\n\nLet's examine how the three approaches compare with a completely random angle distribution:\n\n::: {#ba0c4635 .cell execution_count=7}\n``` {.python .cell-code}\n# Generate a random angle configuration\nnp.random.seed(123)  # For reproducibility\nrandom_angles = np.random.uniform(0, 360, 8)\n\nprint(f\"Random angles: {random_angles}\")\nprint(\"\\nTests with random angles:\")\nfor case in test_cases:\n    # Calculate using the three approaches\n    correct = correct_iso_coordinates(random_angles, case[\"scores\"])\n    original = original_iso_coordinates(random_angles, case[\"scores\"])\n    refined = refined_iso_coordinates(random_angles, case[\"scores\"])\n    \n    print(f\"\\n{case['name']}:\")\n    print(f\"Correct formula: (P={correct[0]:.4f}, E={correct[1]:.4f})\")\n    print(f\"Original approach: (P={original[0]:.4f}, E={original[1]:.4f})\")\n    print(f\"Refined approach: (P={refined[0]:.4f}, E={refined[1]:.4f})\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRandom angles: [250.72890682 103.01016058  81.66652328 198.47331687 259.00882912\n 152.31832564 353.07511142 246.53870589]\n\nTests with random angles:\n\nAll neutral (3):\nCorrect formula: (P=0.0000, E=0.0000)\nOriginal approach: (P=-0.6707, E=-0.2239)\nRefined approach: (P=-1.2133, E=-0.2632)\n\nMaximum pleasant:\nCorrect formula: (P=0.2603, E=-0.0093)\nOriginal approach: (P=-0.4104, E=-0.2332)\nRefined approach: (P=-0.7424, E=-0.2741)\n\nMaximum unpleasant:\nCorrect formula: (P=-0.2603, E=0.0093)\nOriginal approach: (P=-0.9311, E=-0.2146)\nRefined approach: (P=-1.6841, E=-0.2522)\n\nMaximum eventful:\nCorrect formula: (P=-0.1792, E=0.3889)\nOriginal approach: (P=-0.8500, E=0.1650)\nRefined approach: (P=-1.5375, E=0.1940)\n\nMaximum uneventful:\nCorrect formula: (P=0.1792, E=-0.3889)\nOriginal approach: (P=-0.4915, E=-0.6128)\nRefined approach: (P=-0.8890, E=-0.7203)\n```\n:::\n:::\n\n\n## Application to Cross-Cultural Soundscape Research\n\nOur correctly formulated normalization approach is particularly valuable for cross-cultural soundscape research. Let's examine how the normalization affects real language translations from the Soundscape Attributes Translation Project (SATP):\n\n::: {#bb616000 .cell execution_count=8}\n``` {.python .cell-code}\n# Define language examples from SATP\nlanguages = {\n    \"English\": np.array([0, 46, 94, 138, 177, 231, 275, 340]),\n    \"Chinese\": np.array([0, 36, 45, 135, 167, 201, 242, 308]),\n    \"Indonesian\": np.array([0, 53, 104, 123, 139, 202, 284, 308]),\n    \"German\": np.array([0, 64, 97, 132, 182, 254, 282, 336]),\n    \"Italian\": np.array([0, 57, 104, 142, 170, 274, 285, 336]),\n}\n\n# Balanced scores that should give a moderate vibrant result\nbalanced_scores = np.array([4, 4, 4, 3, 2, 2, 2, 3])\n\n# Visualize the impact across languages\nfig, ax = plt.subplots(figsize=(10, 10))\n\n# Draw circles and axes\ncircle = plt.Circle((0, 0), 1, fill=False, linestyle=\"-\", color=\"black\", alpha=0.3)\nax.add_patch(circle)\nax.axhline(y=0, color=\"gray\", linestyle=\"--\", alpha=0.5)\nax.axvline(x=0, color=\"gray\", linestyle=\"--\", alpha=0.5)\n\n# Colors for different languages\ncolors = [\"red\", \"blue\", \"green\", \"purple\", \"orange\"]\nmarkers = [\"o\", \"s\", \"^\", \"D\", \"v\"]\n\n# Plot points for each language\nfor i, (lang, angles) in enumerate(languages.items()):\n    # Calculate with different methods\n    orig_coords = original_iso_coordinates(angles, balanced_scores)\n    refined_coords = refined_iso_coordinates(angles, balanced_scores)\n    correct_coords = correct_iso_coordinates(angles, balanced_scores)\n\n    # Plot the points\n    ax.plot(\n        orig_coords[0],\n        orig_coords[1],\n        marker=markers[i],\n        color=colors[i],\n        linestyle=\"\",\n        markersize=10,\n        alpha=0.5,\n        label=f\"{lang} (Original)\",\n    )\n    ax.plot(\n        refined_coords[0],\n        refined_coords[1],\n        marker=markers[i],\n        color=colors[i],\n        linestyle=\"\",\n        markersize=10,\n        fillstyle=\"none\",\n        label=f\"{lang} (Refined)\",\n    )\n    ax.plot(\n        correct_coords[0],\n        correct_coords[1],\n        marker=\"*\",\n        color=colors[i],\n        linestyle=\"\",\n        markersize=15,\n        label=f\"{lang} (Correct)\",\n    )\n\n    # Connect the points\n    ax.plot(\n        [orig_coords[0], refined_coords[0], correct_coords[0]],\n        [orig_coords[1], refined_coords[1], correct_coords[1]],\n        color=colors[i],\n        linestyle=\"-\",\n        alpha=0.3,\n    )\n\n# Add labels and title\nax.set_xlabel(\"ISO Pleasant\")\nax.set_ylabel(\"ISO Eventful\")\nax.set_title(\n    \"Impact of Normalization Approaches on Soundscape Coordinates\\nAcross Different Languages\"\n)\n\n# Set equal aspect and limits\nax.set_aspect(\"equal\")\nax.set_xlim(-1.1, 1.1)\nax.set_ylim(-1.1, 1.1)\n\n# Add legend\nax.legend(bbox_to_anchor=(1.05, 1), loc=\"upper left\")\n\n# Label the four quadrants\nax.text(0.7, 0.7, \"Vibrant\", ha=\"center\", fontsize=10)\nax.text(-0.7, 0.7, \"Chaotic\", ha=\"center\", fontsize=10)\nax.text(-0.7, -0.7, \"Monotonous\", ha=\"center\", fontsize=10)\nax.text(0.7, -0.7, \"Calm\", ha=\"center\", fontsize=10)\n\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](normalization_files/figure-html/cell-9-output-1.png){width=948 height=733}\n:::\n:::\n\n\n## Conclusion\n\nOur mathematical derivation has produced a robust normalization approach for soundscape circumplex coordinates that ensures:\n\n1. **Accurate centering**: Neutral scores (all 3s) always map to the origin (0,0), regardless of angle distribution\n2. **Proper scaling**: Extreme scores always map to exactly +1 or -1, with intermediate scores properly scaled within this range\n3. **Cross-cultural validity**: The approach works for any arrangement of attributes around the circumplex, making it ideal for multilingual adaptations\n\nThe correct formulation addresses the limitations of previous approaches, providing a solid foundation for cross-cultural soundscape research. By accounting for both the neutral point and the full possible range of scores, this approach ensures consistent and comparable results across different language translations and cultural contexts.\n\nThe formulas derived in this document should be incorporated into the revised ISO 12913-3 standard to ensure accurate soundscape assessment worldwide.\n\n",
    "supporting": [
      "normalization_files"
    ],
    "filters": [],
    "includes": {}
  }
}